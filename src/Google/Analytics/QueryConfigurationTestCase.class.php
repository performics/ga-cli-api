<?php
namespace Google\Analytics;

class QueryConfigurationTestCase extends \TestHelpers\TempFileTestCase {
    /**
     * Converts an array of command-line arguments to the equivalent XML,
     * writes this XML to a temporary file, and returns the path to the file.
     *
     * @param array $args
     * @return string
     */
    private function _argsToXML(array $args) {
        $xml = new \DOMDocument('1.0', 'UTF-8');
        $conf = $xml->createElement('conf');
        $xml->appendChild($conf);
        $queries = $xml->createElement('queries');
        $conf->appendChild($queries);
        $globalArgs = array(
            'email', 'file', 'group-name', 'formatter'
        );
        foreach ($globalArgs as $arg) {
            if (isset($args[$arg])) {
                $conf->setAttribute($arg, $args[$arg]);
                unset($args[$arg]);
            }
        }
        /* See if there are any arrays in the argument list, which means we'll
        be doing multiple queries. */
        $multipleArgs = array();
        $keys = array_keys($args);
        foreach ($keys as $key) {
            if (is_array($args[$key])) {
                $multipleArgs[$key] = $args[$key];
                unset($args[$key]);
            }
        }
        /* If we're doing a single query, just put everything in the <query>
        element; otherwise, put all the single instances in the <conf> element
        and everything else in its own <query> element. */
        if ($multipleArgs) {
            foreach ($args as $arg => $argVal) {
                $conf->setAttribute($arg, $argVal);
            }
            /* It's the responsibility of the test writer to ensure that the
            parameter counts are correct, because we're assuming that we can
            examine an arbitrary member of $multipleArgs and know how many
            queries we're doing. */
            $queryCount = count($multipleArgs[key($multipleArgs)]);
            for ($i = 0; $i < $queryCount; $i++) {
                $query = $xml->createElement('query');
                $queries->appendChild($query);
                foreach ($multipleArgs as $key => $argList) {
                    // We can skip the placeholders
                    if ($argList[$i] == '_') {
                        continue;
                    }
                    // We can also unescape
                    if ($argList[$i] == '\_') {
                        $argList[$i] = '_';
                    }
                    $query->setAttribute($key, $argList[$i]);
                }
            }
        }
        else {
            $query = $xml->createElement('query');
            $queries->appendChild($query);
            foreach ($args as $arg => $argVal) {
                $query->setAttribute($arg, $argVal);
            }
        }
        return $this->_createTempFile(null, $xml->saveXML());
    }
    
    /**
     * Given an expected query and an argument array, asserts that the given
     * arguments generate the expected query, and that the configuration
     * generated by the arguments matches that generated by the equivalent XML.
     *
     * @param Google\Analytics\IQuery $expectedQuery
     * @param array $args
     */
    private function _assertConfiguration(IQuery $expectedQuery, array $args) {
        $commandLineConfig = QueryConfiguration::createFromCommandLineArgs($args);
        $this->assertEquals($expectedQuery, $commandLineConfig->getQuery());
        $this->assertEquals(
            $commandLineConfig,
            QueryConfiguration::createFromXML($this->_argsToXML($args))
        );
    }
    
    /**
     * Tests instantiation from command-line arguments and the equivalent XML.
     */
    public function testInstantiation() {
        $args = array(
            'profile-id' => '12345',
            'email' => 'foo@bar.baz',
            'start-date' => '2015-01-01',
            'end-date' => '2015-01-31',
            'metric' => 'foo'
        );
        $expectedQuery = new GaDataQuery();
        $expectedQuery->setProfile($args['profile-id']);
        $expectedQuery->setStartDate($args['start-date']);
        $expectedQuery->setEndDate($args['end-date']);
        $expectedQuery->setMetrics($args['metric']);
        $this->_assertConfiguration($expectedQuery, $args);
        unset($args['profile-id']);
        $args['profile-name'] = 'Foo Industries Inc.';
        $expectedQuery = new GaDataQuery();
        $expectedQuery->setProfileName($args['profile-name']);
        $expectedQuery->setStartDate($args['start-date']);
        $expectedQuery->setEndDate($args['end-date']);
        $expectedQuery->setMetrics($args['metric']);
        $this->_assertConfiguration($expectedQuery, $args);
        $args['metric'] = 'foo,bar';
        $expectedQuery->setMetrics(array('foo', 'bar'));
        $this->_assertConfiguration($expectedQuery, $args);
        $args['dimension'] = 'baz';
        $expectedQuery->setDimensions($args['dimension']);
        $this->_assertConfiguration($expectedQuery, $args);
        $args['dimension'] = 'baz,borg';
        $expectedQuery->setDimensions(array('baz', 'borg'));
        $this->_assertConfiguration($expectedQuery, $args);
        $args['sort'] = 'foo';
        $sortOrder = new GaDataSortOrder();
        $sortOrder->addField('foo');
        $expectedQuery->setSort($sortOrder);
        $this->_assertConfiguration($expectedQuery, $args);
        $args['sort'] = 'foo,-baz';
        $sortOrder->addField('baz', SORT_DESC);
        // No need to set the sort order again, since it's an object
        $this->_assertConfiguration($expectedQuery, $args);
        $args['filter'] = 'ga:foo>=1';
        /* It's a bit counter-intuitive, but the filter string above will be
        interpreted as a Google\Analytics\GaDataFilterCollection object with
        another instance of the same object as the sole member; this member
        will have the conditional expression itself and the logical operator
        "," (OR). This is what allows the mixing or ORs and ANDs. */
        $filter = new GaDataFilterCollection(
            GaDataFilterCollection::OP_AND,
            new GaDataFilterCollection(
                GaDataFilterCollection::OP_OR,
                new GaDataConditionalExpression('foo', GaDataConditionalExpression::OP_GE, 1)
            )
        );
        $expectedQuery->setFilter($filter);
        $this->_assertConfiguration($expectedQuery, $args);
        $args['filter'] .= ';ga:bar!=baz';
        $filter = new GaDataFilterCollection(
            GaDataFilterCollection::OP_AND,
            new GaDataFilterCollection(
                GaDataFilterCollection::OP_OR,
                new GaDataConditionalExpression('foo', GaDataConditionalExpression::OP_GE, 1)
            ),
            new GaDataFilterCollection(
                GaDataFilterCollection::OP_OR,
                new GaDataConditionalExpression('bar', GaDataConditionalExpression::OP_NE, 'baz')
            )
        );
        $expectedQuery->setFilter($filter);
        $this->_assertConfiguration($expectedQuery, $args);
        $args['filter'] = 'ga:foo<20,ga:bar==baz';
        $filter = new GaDataFilterCollection(
            GaDataFilterCollection::OP_AND,
            new GaDataFilterCollection(
                GaDataFilterCollection::OP_OR,
                new GaDataConditionalExpression('foo', GaDataConditionalExpression::OP_LT, 20),
                new GaDataConditionalExpression('bar', GaDataConditionalExpression::OP_EQ, 'baz')
            )
        );
        $expectedQuery->setFilter($filter);
        $this->_assertConfiguration($expectedQuery, $args);
        // Segments can be numeric IDs
        $args['segment'] = '-2';
        $expectedQuery->setSegment(-2);
        $this->_assertConfiguration($expectedQuery, $args);
        // The can also be strings
        $args['segment'] = 'users::condition::ga:foo<20';
        $expectedQuery->setSegment($args['segment']);
        $this->_assertConfiguration($expectedQuery, $args);
        /* They can also be objects, but at the moment this isn't really
        testable because I have put off implementing
        Google\Analytics\GaDataSegment::createFromString().
        $args['segment'] = 'users::condition::ga:foo<20';
        $segment = new GaDataSegment(
            new GaDataSegmentConditionGroup(
                new GaDataSegmentSimpleCondition(
                    'foo', GaDataSegmentSimpleCondition::OP_LT, 20
                )
            ),
            GaDataSegment::SCOPE_USERS
        );
        $expectedQuery->setSegment($segment);
        $this->_assertConfiguration($expectedQuery, $args);
        $args['segment'] = 'users::condition::ga:foo<20;sessions::sequence::ga:bar==baz->ga:baz>0';
        $segment = new GaDataSegment(
            new GaDataSegmentConditionGroup(
                new GaDataSegmentSimpleCondition(
                    'foo', GaDataSegmentSimpleCondition::OP_LT, 20
                )
            ),
            GaDataSegment::SCOPE_USERS,
            new GaDataSegmentSequence(
                new GaDataSegmentSequenceCondition(
                    'bar', GaDataSegmentSequenceCondition::OP_EQ, 'baz'
                ),
                new GaDataSegmentSequenceCondition(
                    'baz', GaDataSegmentSequenceCondition::OP_GT, 0, GaDataSegmentSequenceCondition::OP_FOLLOWED_BY_IMMEDIATE
                )
            ),
            GaDataSegment::SCOPE_SESSIONS
        );
        $this->_assertConfiguration($expectedQuery, $args);
        */
        $args['sampling-level'] = 'higher_precision';
        $expectedQuery->setSamplingLevel(
            GaDataQuery::SAMPLING_LEVEL_HIGHER_PRECISION
        );
        $this->_assertConfiguration($expectedQuery, $args);
        $args['name'] = 'Some report name';
        $expectedQuery->setName($args['name']);
        $this->_assertConfiguration($expectedQuery, $args);
        /* If we are splitting queries, we should get a
        Google\Analytics\DateRangeGaDataQuery object. */
        $args['split-queries-by'] = 'day';
        $expectedDateRangeQuery = new DateRangeGaDataQuery();
        $expectedDateRangeQuery->setSummaryStartDate($expectedQuery->getStartDate());
        $expectedDateRangeQuery->setSummaryEndDate($expectedQuery->getEndDate());
        $expectedDateRangeQuery->setIterationInterval(new \DateInterval('P1D'));
        $expectedDateRangeQuery->setIterativeName('Day');
        $expectedDateRangeQuery->setMetrics($expectedQuery->getMetrics());
        $expectedDateRangeQuery->setProfileName($args['profile-name']);
        $expectedDateRangeQuery->setDimensions($expectedQuery->getDimensions());
        $expectedDateRangeQuery->setSort($expectedQuery->getSort());
        $expectedDateRangeQuery->setFilter($expectedQuery->getFilter());
        $expectedDateRangeQuery->setSegment($expectedQuery->getSegment());
        $expectedDateRangeQuery->setSamplingLevel($expectedQuery->getSamplingLevel());
        $expectedDateRangeQuery->setName($expectedQuery->getName());
        $this->_assertConfiguration($expectedDateRangeQuery, $args);
        /* If we use multiple instances of certain parameters, we should get a
        Google\Analytics\GaDataQueryCollection object. All parameters that are
        supplied as a single instance will be shared by all individual queries
        in the collection. */
        unset($args['split-queries-by']);
        $args['name'] = array($args['name']);
        $args['name'][] = 'Some other report name';
        $expectedQuery2 = clone $expectedQuery;
        $expectedQuery2->setName('Some other report name');
        $expectedQueryCollection = new GaDataQueryCollection(
            $expectedQuery, $expectedQuery2
        );
        $this->_assertConfiguration($expectedQueryCollection, $args);
        // An underscore is treated as a placeholder and ignored
        $args = array(
            'profile-id' => '12345',
            'start-date' => '2015-01-01',
            'end-date' => '2015-01-31',
            'email' => 'foo@bar.baz',
            'metric' => array('foo', 'bar'),
            'segment' => array('users::condition::ga:foo<20', '_'),
            'group-name' => 'Some name'
        );
        $expectedQuery = new GaDataQuery();
        $expectedQuery->setProfile($args['profile-id']);
        $expectedQuery->setStartDate($args['start-date']);
        $expectedQuery->setEndDate($args['end-date']);
        $expectedQuery2 = clone $expectedQuery;
        $expectedQuery->setMetrics($args['metric'][0]);
        $expectedQuery2->setMetrics($args['metric'][1]);
        $expectedQuery->setSegment($args['segment'][0]);
        $expectedQueryCollection = new GaDataQueryCollection(
            $expectedQuery, $expectedQuery2
        );
        $expectedQueryCollection->setName($args['group-name']);
        $this->_assertConfiguration($expectedQueryCollection, $args);
        // Unless the underscore is escaped
        $args['sort'] = array('foo', '\_');
        $sortOrder = new GaDataSortOrder();
        $sortOrder->addField('foo');
        $expectedQuery->setSort($sortOrder);
        $sortOrder = new GaDataSortOrder();
        $sortOrder->addField('_');
        $expectedQuery2->setSort($sortOrder);
        $this->_assertConfiguration($expectedQueryCollection, $args);
        // We can split by an interval in any of the queries we get back
        $args['metric'][] = $args['metric'][0];
        $args['segment'][] = $args['segment'][0];
        $args['sort'][] = $args['sort'][0];
        $args['split-queries-by'] = array('_', '_', 'week');
        $expectedQuery3 = new DateRangeGaDataQuery();
        $expectedQuery3->setSummaryStartDate($expectedQuery->getStartDate());
        $expectedQuery3->setSummaryEndDate($expectedQuery->getEndDate());
        $expectedQuery3->setIterationInterval(new \DateInterval('P1W'));
        $expectedQuery3->setIterativeName('Week');
        $expectedQuery3->setProfile($args['profile-id']);
        $expectedQuery3->setMetrics($expectedQuery->getMetrics());
        $expectedQuery3->setSegment($expectedQuery->getSegment());
        $expectedQuery3->setSort($expectedQuery->getSort());
        $expectedQueryCollection = new GaDataQueryCollection(
            $expectedQuery, $expectedQuery2, $expectedQuery3
        );
        $expectedQueryCollection->setName($args['group-name']);
        $this->_assertConfiguration($expectedQueryCollection, $args);
        /* Make sure we get exceptions where necessary, e.g. the lack of a
        profile specifier. */
        unset($args['profile-id']);
        $this->assertThrows(
            __NAMESPACE__ . '\InvalidArgumentException',
            array(__NAMESPACE__ . '\QueryConfiguration', 'createFromCommandLineArgs'),
            array($args)
        );
        $this->assertEquals(
            'A profile name or ID must be specified.',
            $this->_lastException->getMessage()
        );
        // Or inconsistent parameter counts
        $args['profile-id'] = '12345';
        $args['sort'][] = 'asdf';
        $this->assertThrows(
            __NAMESPACE__ . '\InvalidArgumentException',
            array(__NAMESPACE__ . '\QueryConfiguration', 'createFromCommandLineArgs'),
            array($args)
        );
        $this->assertContains(
            'Please ensure that all arguments are invoked either a ' .
            'single time only or the same number of times.',
            $this->_lastException->getMessage()
        );
    }
    
    /**
     * Confirms that errors in the XML configuration throw exceptions.
     */
    public function testMalformedXML() {
        /* Allow the parser to be loose about the XML so my exceptions have a
        chance to get thrown. */
        libxml_use_internal_errors(true);
        $this->assertThrows(
            __NAMESPACE__ . '\InvalidArgumentException',
            array(__NAMESPACE__ . '\QueryConfiguration', 'createFromXML'),
            array('/some/file/that/does/not/exist')
        );
        // Junk XML should be intercepted
        $this->assertThrows(
            __NAMESPACE__ . '\RuntimeException',
            array(__NAMESPACE__ . '\QueryConfiguration', 'createFromXML'),
            array($this->_createTempFile(null, 'oasidfjpioasdjf'))
        );
        /* The XML must contain exactly one <conf> element at the outermost
        level. */
        $xml = <<<EOF
<?xml version="1.0" encoding="UTF-8"?>
<foo></foo>
EOF;
        $this->assertThrows(
            __NAMESPACE__ . '\UnexpectedValueException',
            array(__NAMESPACE__ . '\QueryConfiguration', 'createFromXML'),
            array($this->_createTempFile(null, $xml))
        );
        $xml = <<<EOF
<?xml version="1.0" encoding="UTF-8"?>
<conf><queries><query/></queries></conf>
<conf><queries><query/></queries></conf>
EOF;
        /* This raises a Google\Analytics\RuntimeException because the XML
        parser will not treat the content as valid without a single containing
        element. */
        $this->assertThrows(
            __NAMESPACE__ . '\RuntimeException',
            array(__NAMESPACE__ . '\QueryConfiguration', 'createFromXML'),
            array($this->_createTempFile(null, $xml))
        );
        // The <conf> element must contain exactly one <queries> element
        $xml = <<<EOF
<?xml version="1.0" encoding="UTF-8"?>
<conf></conf>
EOF;
        $this->assertThrows(
            __NAMESPACE__ . '\UnexpectedValueException',
            array(__NAMESPACE__ . '\QueryConfiguration', 'createFromXML'),
            array($this->_createTempFile(null, $xml))
        );
        $xml = <<<EOF
<?xml version="1.0" encoding="UTF-8"?>
<conf><queries><query/></queries><queries><query/></queries></conf>
EOF;
        $this->assertThrows(
            __NAMESPACE__ . '\UnexpectedValueException',
            array(__NAMESPACE__ . '\QueryConfiguration', 'createFromXML'),
            array($this->_createTempFile(null, $xml))
        );
        // The <queries> element must contain at least one <query> element
        $xml = <<<EOF
<?xml version="1.0" encoding="UTF-8"?>
<conf><queries></queries></conf>
EOF;
        $this->assertThrows(
            __NAMESPACE__ . '\UnexpectedValueException',
            array(__NAMESPACE__ . '\QueryConfiguration', 'createFromXML'),
            array($this->_createTempFile(null, $xml))
        );
        // Going recursive isn't allowed
        $xml = <<<EOF
<?xml version="1.0" encoding="UTF-8"?>
<conf><queries><query/></queries></conf>
EOF;
        $t = $this->_createTempFile(null, $xml);
        $xml = <<<EOF
<?xml version="1.0" encoding="UTF-8"?>
<conf conf="{$t}"><queries><query/></queries></conf>
EOF;
        $this->assertThrows(
            __NAMESPACE__ . '\UnexpectedValueException',
            array(__NAMESPACE__ . '\QueryConfiguration', 'createFromXML'),
            array($this->_createTempFile(null, $xml))
        );
    }
}
?>